Relevant Report:

Performance of MAX-CLIQUE Approximation Heuristics 
Under Description-length Weighted Distributions

Arun Jagota and Kenneth W. Regan
Technical Report, Department of Computer Science, 
State University of New York at Buffalo, October 1992

Avaliable in the current ftp directory (see Section `ACCESS TO CODE' later in 
case you forget)

PROGRAM SOURCE.
---------------
Is in the shar file `nlt_source.shar' in the current ftp directory 

To build:
sh nlt_source.shar
cc -o nlt -lm nlt.c
cc -o nlt_dec nlt_dec.c
cc -o rsb -lm rsb.c
cc -o graph graph.c
cc -o trunc trunc.c

The file nlt_source.shar also contains a shell script `nlt_sampler' which
facilitates sampling from q(x) [See comments in script; also see examples
that follow and the brief "TUTORIAL"].

The file nlt_source.shar also contains a Mathematica Implementation of
Continuous Hopfield Dynamics and Mean Field Annealing as applied to 
MAX-CLIQUE in the file: CHDandMFA.m

An example of use:

> rsb 1 30 10
010010111100000010011011100100
> rsb 1 30 10 | nlt_dec 30
00 D 011 E 10 01 R0 0 0  .
> rsb 1 30 10 | nlt_dec 30 | nlt 100
1010
> rsb 1 30 10 | nlt_dec 30 | nlt 100 | trunc 4
baba
> rsb 1 30 10 | nlt_dec 30 | nlt 100 | trunc 4 | graph 2
{ v1 v2 } 

See another example later in the tutorial for explanation of `rsb', `nlt_dec',
and `nlt'. `trunc' takes a `0/1' string as input and converts it into an `a/b' 
string truncated to the specified length (4 in the above example). `graph' 
takes a `a/b' string as stdin input (`a' means `0'; `b' means `1') and the 
number of vertices as command line argument and outputs the set of edges.
trunc is useful for truncating the string to exactly the number of edge-slots 
in a particular graph (e.g. 4950 for 100-vertex graphs).

                "TUTORIAL" ON SAMPLING FROM q(x)
      (Same as Appendix I in MAX-CLIQUE approximation paper)

The procedure for sampling from the description-length weighted distribution 
q(x) is as follows:

1. A random binary string s in {0,1}^m is generated.

2. s is decoded as a pair (P,x), where P is a Gurevich-Shelah program which 
   when run on x produces a binary string y.

s is thus a description of the string y.

Informally speaking, the above procedure is repeated and all strings y such 
that |y| >> |s| are recorded. The obtained strings y are highly compressible 
and hence represent samples from a description-length weighted distribution, 
namely q(x).

THE s-to-(P,x) DECODER.
-----------------------
The decoder interprets s as a ``self-delimiting'' description for the program 
P and binary string x. It has been designed with care to ensure that most 
Gurevich-Shelah programs are reasonably likely, given the length m of s.
Here, we present only the main ideas. 

1. The first floor([log m]/2) bits of the m-bit string s are interpreted as 
storing the length l of x. The next l bits are pulled off for the argument
x itself.  Let r be the number of bits which remain.

2. The first floor([log r]/2) bits of the remaining r bits are interpreted as 
storing the number of basic Gurevich-Shelah functions in P.

3. Let nc denote the number of functions found as above. The next 
floor([log nc]/2) bits are interpreted as storing the number of iterated 
replacements in the program string.  These iterated replacements are
represented in the program string by placing parentheses around the functions 
involved in the replacement.

4. The next set of bits indicates where parentheses for iterated replacements
are located.

5. The next set of 3nc-many bits identify the basic functions in the program 
string. Three bits are used to encode each occurrence of the eight basic 
functions.

6. The next set of bits is decoded as a self-delimiting value of the total 
length of the parameter strings for each basic function. 

7. The remaining bits are decoded and divided up among the parameters for each 
basic function according to the syntax of the operator and the length decoded 
in the above step.

AN EXAMPLE. 
-----------
The following example was obtained from an actual run, using the following 
command.

rsb 1 30 10 | nlt_dec 30 | nlt 100

s   =      010010111100000010011011100100
x,P =      00 D 011 E 10 01 R0 0 0  .
y   =      1010

In this case, the output y is shorter than s, and so not very useful. `rsb' 
generates the random string s of length 30 with seed 10 (third command-line 
argument). `nlt_dec' decodes s. It takes |s| as the command-line argument. In 
its output, the first string is x; the rest P. In P, the operators are 
identified by name and followed by their parameter strings. The processing is 
left-to-right; the input to each operator is the output of the previous one 
(or x for the first operator). `nlt' runs P on x.

ACCESS TO CODE.
---------------
The above code is accessible via ftp as follows:

ftp ftp.cs.buffalo.edu (128.205.32.9 subject-to-change)
Name : anonymous
> cd users/jagota
> get nlt.README
> quit

nlt.README provides further instructions.

If there are problems accessing the code, contact jagota@cs.buffalo.edu.

TIPS ON USAGE.
--------------
We think that our programs may be used to generate highly compressible inputs 
for any application whose inputs are binary strings (vectors) or other 
structures (e.g. graphs in our case) that can be obtained from binary 
strings. 

1. Though the sampling is quite efficient (one of roughly every six seed 
strings in our case generated a highly compressible string), the running time 
of `nlt' scales poorly as the size of y increases. The current version of 
`nlt' uses the direct quadratic-time method of computing iterated 
replacements, rather than the near-linear time tree-structured method sketched 
in [GuSh89]. Perhaps more importantly, `nlt' has not been optimized for string
pattern matching operations, which occur frequently in Gurevich-Shelah 
functions. Currently, pattern matching is done by brute force.

2. For this scheme to work well, the seed strings should be reasonably large 
(upwards of 70 bits in our case). Smaller strings produce less variability in 
the programs P. Couple this with the desirability of high compression (e.g 
squareroot in our case), the target output should preferably be upwards of 
1000 bits (4950 in our case). 

ALTERNATIVE SIMPLE COMPRESSIBLE STRING GENERATION SCHEME
--------------------------------------------------------
Perhaps a simple compressible string generation scheme is as follows:
Generate a random n-bit string y and make a string x comprised of n copies of y.
y thus has a quadratic compression. And variants of the above idea...
